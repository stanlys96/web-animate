{"ast":null,"code":"import { useEffect, useContext } from 'react';\nimport { isAnimationControls } from '../../animation/utils/is-animation-controls.mjs';\nimport { usePresence } from '../../components/AnimatePresence/use-presence.mjs';\nimport { PresenceContext } from '../../context/PresenceContext.mjs';\nimport { createAnimationState } from '../../render/utils/animation-state.mjs';\nimport { AnimationType } from '../../render/utils/types.mjs';\nimport { makeRenderlessComponent } from '../utils/make-renderless-component.mjs';\nconst animations = {\n  animation: makeRenderlessComponent(_ref => {\n    let {\n      visualElement,\n      animate\n    } = _ref;\n    /**\n     * We dynamically generate the AnimationState manager as it contains a reference\n     * to the underlying animation library. We only want to load that if we load this,\n     * so people can optionally code split it out using the `m` component.\n     */\n    visualElement.animationState || (visualElement.animationState = createAnimationState(visualElement));\n    /**\n     * Subscribe any provided AnimationControls to the component's VisualElement\n     */\n    if (isAnimationControls(animate)) {\n      useEffect(() => animate.subscribe(visualElement), [animate]);\n    }\n  }),\n  exit: makeRenderlessComponent(props => {\n    const {\n      custom,\n      visualElement\n    } = props;\n    const [isPresent, safeToRemove] = usePresence();\n    const presenceContext = useContext(PresenceContext);\n    useEffect(() => {\n      var _a, _b;\n      visualElement.isPresent = isPresent;\n      const animation = (_a = visualElement.animationState) === null || _a === void 0 ? void 0 : _a.setActive(AnimationType.Exit, !isPresent, {\n        custom: (_b = presenceContext === null || presenceContext === void 0 ? void 0 : presenceContext.custom) !== null && _b !== void 0 ? _b : custom\n      });\n      !isPresent && (animation === null || animation === void 0 ? void 0 : animation.then(safeToRemove));\n    }, [isPresent]);\n  })\n};\nexport { animations };","map":{"version":3,"names":["useEffect","useContext","isAnimationControls","usePresence","PresenceContext","createAnimationState","AnimationType","makeRenderlessComponent","animations","animation","_ref","visualElement","animate","animationState","subscribe","exit","props","custom","isPresent","safeToRemove","presenceContext","_a","_b","setActive","Exit","then"],"sources":["/Users/stanly_s/Documents/yocia/node_modules/framer-motion/dist/es/motion/features/animations.mjs"],"sourcesContent":["import { useEffect, useContext } from 'react';\nimport { isAnimationControls } from '../../animation/utils/is-animation-controls.mjs';\nimport { usePresence } from '../../components/AnimatePresence/use-presence.mjs';\nimport { PresenceContext } from '../../context/PresenceContext.mjs';\nimport { createAnimationState } from '../../render/utils/animation-state.mjs';\nimport { AnimationType } from '../../render/utils/types.mjs';\nimport { makeRenderlessComponent } from '../utils/make-renderless-component.mjs';\n\nconst animations = {\n    animation: makeRenderlessComponent(({ visualElement, animate }) => {\n        /**\n         * We dynamically generate the AnimationState manager as it contains a reference\n         * to the underlying animation library. We only want to load that if we load this,\n         * so people can optionally code split it out using the `m` component.\n         */\n        visualElement.animationState || (visualElement.animationState = createAnimationState(visualElement));\n        /**\n         * Subscribe any provided AnimationControls to the component's VisualElement\n         */\n        if (isAnimationControls(animate)) {\n            useEffect(() => animate.subscribe(visualElement), [animate]);\n        }\n    }),\n    exit: makeRenderlessComponent((props) => {\n        const { custom, visualElement } = props;\n        const [isPresent, safeToRemove] = usePresence();\n        const presenceContext = useContext(PresenceContext);\n        useEffect(() => {\n            var _a, _b;\n            visualElement.isPresent = isPresent;\n            const animation = (_a = visualElement.animationState) === null || _a === void 0 ? void 0 : _a.setActive(AnimationType.Exit, !isPresent, { custom: (_b = presenceContext === null || presenceContext === void 0 ? void 0 : presenceContext.custom) !== null && _b !== void 0 ? _b : custom });\n            !isPresent && (animation === null || animation === void 0 ? void 0 : animation.then(safeToRemove));\n        }, [isPresent]);\n    }),\n};\n\nexport { animations };\n"],"mappings":"AAAA,SAASA,SAAS,EAAEC,UAAU,QAAQ,OAAO;AAC7C,SAASC,mBAAmB,QAAQ,iDAAiD;AACrF,SAASC,WAAW,QAAQ,mDAAmD;AAC/E,SAASC,eAAe,QAAQ,mCAAmC;AACnE,SAASC,oBAAoB,QAAQ,wCAAwC;AAC7E,SAASC,aAAa,QAAQ,8BAA8B;AAC5D,SAASC,uBAAuB,QAAQ,wCAAwC;AAEhF,MAAMC,UAAU,GAAG;EACfC,SAAS,EAAEF,uBAAuB,CAACG,IAAA,IAAgC;IAAA,IAA/B;MAAEC,aAAa;MAAEC;IAAQ,CAAC,GAAAF,IAAA;IAC1D;AACR;AACA;AACA;AACA;IACQC,aAAa,CAACE,cAAc,KAAKF,aAAa,CAACE,cAAc,GAAGR,oBAAoB,CAACM,aAAa,CAAC,CAAC;IACpG;AACR;AACA;IACQ,IAAIT,mBAAmB,CAACU,OAAO,CAAC,EAAE;MAC9BZ,SAAS,CAAC,MAAMY,OAAO,CAACE,SAAS,CAACH,aAAa,CAAC,EAAE,CAACC,OAAO,CAAC,CAAC;IAChE;EACJ,CAAC,CAAC;EACFG,IAAI,EAAER,uBAAuB,CAAES,KAAK,IAAK;IACrC,MAAM;MAAEC,MAAM;MAAEN;IAAc,CAAC,GAAGK,KAAK;IACvC,MAAM,CAACE,SAAS,EAAEC,YAAY,CAAC,GAAGhB,WAAW,CAAC,CAAC;IAC/C,MAAMiB,eAAe,GAAGnB,UAAU,CAACG,eAAe,CAAC;IACnDJ,SAAS,CAAC,MAAM;MACZ,IAAIqB,EAAE,EAAEC,EAAE;MACVX,aAAa,CAACO,SAAS,GAAGA,SAAS;MACnC,MAAMT,SAAS,GAAG,CAACY,EAAE,GAAGV,aAAa,CAACE,cAAc,MAAM,IAAI,IAAIQ,EAAE,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,EAAE,CAACE,SAAS,CAACjB,aAAa,CAACkB,IAAI,EAAE,CAACN,SAAS,EAAE;QAAED,MAAM,EAAE,CAACK,EAAE,GAAGF,eAAe,KAAK,IAAI,IAAIA,eAAe,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,eAAe,CAACH,MAAM,MAAM,IAAI,IAAIK,EAAE,KAAK,KAAK,CAAC,GAAGA,EAAE,GAAGL;MAAO,CAAC,CAAC;MAC5R,CAACC,SAAS,KAAKT,SAAS,KAAK,IAAI,IAAIA,SAAS,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,SAAS,CAACgB,IAAI,CAACN,YAAY,CAAC,CAAC;IACtG,CAAC,EAAE,CAACD,SAAS,CAAC,CAAC;EACnB,CAAC;AACL,CAAC;AAED,SAASV,UAAU","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}