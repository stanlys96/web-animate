{"ast":null,"code":"import { useRef } from 'react';\nimport { isNodeOrChild } from './utils/is-node-or-child.mjs';\nimport { usePointerEvent, addPointerEvent } from '../events/use-pointer-event.mjs';\nimport { useUnmountEffect } from '../utils/use-unmount-effect.mjs';\nimport { pipe } from 'popmotion';\nimport { AnimationType } from '../render/utils/types.mjs';\nimport { isDragActive } from './drag/utils/lock.mjs';\n\n/**\n * @param handlers -\n * @internal\n */\nfunction useTapGesture(_ref) {\n  let {\n    onTap,\n    onTapStart,\n    onTapCancel,\n    whileTap,\n    visualElement\n  } = _ref;\n  const hasPressListeners = onTap || onTapStart || onTapCancel || whileTap;\n  const isPressing = useRef(false);\n  const cancelPointerEndListeners = useRef(null);\n  /**\n   * Only set listener to passive if there are no external listeners.\n   */\n  const eventOptions = {\n    passive: !(onTapStart || onTap || onTapCancel || onPointerDown)\n  };\n  function removePointerEndListener() {\n    var _a;\n    (_a = cancelPointerEndListeners.current) === null || _a === void 0 ? void 0 : _a.call(cancelPointerEndListeners);\n    cancelPointerEndListeners.current = null;\n  }\n  function checkPointerEnd() {\n    var _a;\n    removePointerEndListener();\n    isPressing.current = false;\n    (_a = visualElement.animationState) === null || _a === void 0 ? void 0 : _a.setActive(AnimationType.Tap, false);\n    return !isDragActive();\n  }\n  function onPointerUp(event, info) {\n    if (!checkPointerEnd()) return;\n    /**\n     * We only count this as a tap gesture if the event.target is the same\n     * as, or a child of, this component's element\n     */\n    !isNodeOrChild(visualElement.getInstance(), event.target) ? onTapCancel === null || onTapCancel === void 0 ? void 0 : onTapCancel(event, info) : onTap === null || onTap === void 0 ? void 0 : onTap(event, info);\n  }\n  function onPointerCancel(event, info) {\n    if (!checkPointerEnd()) return;\n    onTapCancel === null || onTapCancel === void 0 ? void 0 : onTapCancel(event, info);\n  }\n  function onPointerDown(event, info) {\n    var _a;\n    removePointerEndListener();\n    if (isPressing.current) return;\n    isPressing.current = true;\n    cancelPointerEndListeners.current = pipe(addPointerEvent(window, \"pointerup\", onPointerUp, eventOptions), addPointerEvent(window, \"pointercancel\", onPointerCancel, eventOptions));\n    /**\n     * Ensure we trigger animations before firing event callback\n     */\n    (_a = visualElement.animationState) === null || _a === void 0 ? void 0 : _a.setActive(AnimationType.Tap, true);\n    onTapStart === null || onTapStart === void 0 ? void 0 : onTapStart(event, info);\n  }\n  usePointerEvent(visualElement, \"pointerdown\", hasPressListeners ? onPointerDown : undefined, eventOptions);\n  useUnmountEffect(removePointerEndListener);\n}\nexport { useTapGesture };","map":{"version":3,"names":["useRef","isNodeOrChild","usePointerEvent","addPointerEvent","useUnmountEffect","pipe","AnimationType","isDragActive","useTapGesture","_ref","onTap","onTapStart","onTapCancel","whileTap","visualElement","hasPressListeners","isPressing","cancelPointerEndListeners","eventOptions","passive","onPointerDown","removePointerEndListener","_a","current","call","checkPointerEnd","animationState","setActive","Tap","onPointerUp","event","info","getInstance","target","onPointerCancel","window","undefined"],"sources":["/Users/stanly_s/Documents/yocia/node_modules/framer-motion/dist/es/gestures/use-tap-gesture.mjs"],"sourcesContent":["import { useRef } from 'react';\nimport { isNodeOrChild } from './utils/is-node-or-child.mjs';\nimport { usePointerEvent, addPointerEvent } from '../events/use-pointer-event.mjs';\nimport { useUnmountEffect } from '../utils/use-unmount-effect.mjs';\nimport { pipe } from 'popmotion';\nimport { AnimationType } from '../render/utils/types.mjs';\nimport { isDragActive } from './drag/utils/lock.mjs';\n\n/**\n * @param handlers -\n * @internal\n */\nfunction useTapGesture({ onTap, onTapStart, onTapCancel, whileTap, visualElement, }) {\n    const hasPressListeners = onTap || onTapStart || onTapCancel || whileTap;\n    const isPressing = useRef(false);\n    const cancelPointerEndListeners = useRef(null);\n    /**\n     * Only set listener to passive if there are no external listeners.\n     */\n    const eventOptions = {\n        passive: !(onTapStart || onTap || onTapCancel || onPointerDown),\n    };\n    function removePointerEndListener() {\n        var _a;\n        (_a = cancelPointerEndListeners.current) === null || _a === void 0 ? void 0 : _a.call(cancelPointerEndListeners);\n        cancelPointerEndListeners.current = null;\n    }\n    function checkPointerEnd() {\n        var _a;\n        removePointerEndListener();\n        isPressing.current = false;\n        (_a = visualElement.animationState) === null || _a === void 0 ? void 0 : _a.setActive(AnimationType.Tap, false);\n        return !isDragActive();\n    }\n    function onPointerUp(event, info) {\n        if (!checkPointerEnd())\n            return;\n        /**\n         * We only count this as a tap gesture if the event.target is the same\n         * as, or a child of, this component's element\n         */\n        !isNodeOrChild(visualElement.getInstance(), event.target)\n            ? onTapCancel === null || onTapCancel === void 0 ? void 0 : onTapCancel(event, info)\n            : onTap === null || onTap === void 0 ? void 0 : onTap(event, info);\n    }\n    function onPointerCancel(event, info) {\n        if (!checkPointerEnd())\n            return;\n        onTapCancel === null || onTapCancel === void 0 ? void 0 : onTapCancel(event, info);\n    }\n    function onPointerDown(event, info) {\n        var _a;\n        removePointerEndListener();\n        if (isPressing.current)\n            return;\n        isPressing.current = true;\n        cancelPointerEndListeners.current = pipe(addPointerEvent(window, \"pointerup\", onPointerUp, eventOptions), addPointerEvent(window, \"pointercancel\", onPointerCancel, eventOptions));\n        /**\n         * Ensure we trigger animations before firing event callback\n         */\n        (_a = visualElement.animationState) === null || _a === void 0 ? void 0 : _a.setActive(AnimationType.Tap, true);\n        onTapStart === null || onTapStart === void 0 ? void 0 : onTapStart(event, info);\n    }\n    usePointerEvent(visualElement, \"pointerdown\", hasPressListeners ? onPointerDown : undefined, eventOptions);\n    useUnmountEffect(removePointerEndListener);\n}\n\nexport { useTapGesture };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}