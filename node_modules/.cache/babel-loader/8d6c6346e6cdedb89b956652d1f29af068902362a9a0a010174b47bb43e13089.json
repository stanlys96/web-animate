{"ast":null,"code":"import { __rest } from 'tslib';\n\n/**\n * Map an IntersectionHandler callback to an element. We only ever make one handler for one\n * element, so even though these handlers might all be triggered by different\n * observers, we can keep them in the same map.\n */\nconst observerCallbacks = new WeakMap();\n/**\n * Multiple observers can be created for multiple element/document roots. Each with\n * different settings. So here we store dictionaries of observers to each root,\n * using serialised settings (threshold/margin) as lookup keys.\n */\nconst observers = new WeakMap();\nconst fireObserverCallback = entry => {\n  var _a;\n  (_a = observerCallbacks.get(entry.target)) === null || _a === void 0 ? void 0 : _a(entry);\n};\nconst fireAllObserverCallbacks = entries => {\n  entries.forEach(fireObserverCallback);\n};\nfunction initIntersectionObserver(_a) {\n  var {\n      root\n    } = _a,\n    options = __rest(_a, [\"root\"]);\n  const lookupRoot = root || document;\n  /**\n   * If we don't have an observer lookup map for this root, create one.\n   */\n  if (!observers.has(lookupRoot)) {\n    observers.set(lookupRoot, {});\n  }\n  const rootObservers = observers.get(lookupRoot);\n  const key = JSON.stringify(options);\n  /**\n   * If we don't have an observer for this combination of root and settings,\n   * create one.\n   */\n  if (!rootObservers[key]) {\n    rootObservers[key] = new IntersectionObserver(fireAllObserverCallbacks, Object.assign({\n      root\n    }, options));\n  }\n  return rootObservers[key];\n}\nfunction observeIntersection(element, options, callback) {\n  const rootInteresectionObserver = initIntersectionObserver(options);\n  observerCallbacks.set(element, callback);\n  rootInteresectionObserver.observe(element);\n  return () => {\n    observerCallbacks.delete(element);\n    rootInteresectionObserver.unobserve(element);\n  };\n}\nexport { observeIntersection };","map":{"version":3,"names":["__rest","observerCallbacks","WeakMap","observers","fireObserverCallback","entry","_a","get","target","fireAllObserverCallbacks","entries","forEach","initIntersectionObserver","root","options","lookupRoot","document","has","set","rootObservers","key","JSON","stringify","IntersectionObserver","Object","assign","observeIntersection","element","callback","rootInteresectionObserver","observe","delete","unobserve"],"sources":["/Users/stanly_s/Documents/yocia/node_modules/framer-motion/dist/es/motion/features/viewport/observers.mjs"],"sourcesContent":["import { __rest } from 'tslib';\n\n/**\n * Map an IntersectionHandler callback to an element. We only ever make one handler for one\n * element, so even though these handlers might all be triggered by different\n * observers, we can keep them in the same map.\n */\nconst observerCallbacks = new WeakMap();\n/**\n * Multiple observers can be created for multiple element/document roots. Each with\n * different settings. So here we store dictionaries of observers to each root,\n * using serialised settings (threshold/margin) as lookup keys.\n */\nconst observers = new WeakMap();\nconst fireObserverCallback = (entry) => {\n    var _a;\n    (_a = observerCallbacks.get(entry.target)) === null || _a === void 0 ? void 0 : _a(entry);\n};\nconst fireAllObserverCallbacks = (entries) => {\n    entries.forEach(fireObserverCallback);\n};\nfunction initIntersectionObserver(_a) {\n    var { root } = _a, options = __rest(_a, [\"root\"]);\n    const lookupRoot = root || document;\n    /**\n     * If we don't have an observer lookup map for this root, create one.\n     */\n    if (!observers.has(lookupRoot)) {\n        observers.set(lookupRoot, {});\n    }\n    const rootObservers = observers.get(lookupRoot);\n    const key = JSON.stringify(options);\n    /**\n     * If we don't have an observer for this combination of root and settings,\n     * create one.\n     */\n    if (!rootObservers[key]) {\n        rootObservers[key] = new IntersectionObserver(fireAllObserverCallbacks, Object.assign({ root }, options));\n    }\n    return rootObservers[key];\n}\nfunction observeIntersection(element, options, callback) {\n    const rootInteresectionObserver = initIntersectionObserver(options);\n    observerCallbacks.set(element, callback);\n    rootInteresectionObserver.observe(element);\n    return () => {\n        observerCallbacks.delete(element);\n        rootInteresectionObserver.unobserve(element);\n    };\n}\n\nexport { observeIntersection };\n"],"mappings":"AAAA,SAASA,MAAM,QAAQ,OAAO;;AAE9B;AACA;AACA;AACA;AACA;AACA,MAAMC,iBAAiB,GAAG,IAAIC,OAAO,CAAC,CAAC;AACvC;AACA;AACA;AACA;AACA;AACA,MAAMC,SAAS,GAAG,IAAID,OAAO,CAAC,CAAC;AAC/B,MAAME,oBAAoB,GAAIC,KAAK,IAAK;EACpC,IAAIC,EAAE;EACN,CAACA,EAAE,GAAGL,iBAAiB,CAACM,GAAG,CAACF,KAAK,CAACG,MAAM,CAAC,MAAM,IAAI,IAAIF,EAAE,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,EAAE,CAACD,KAAK,CAAC;AAC7F,CAAC;AACD,MAAMI,wBAAwB,GAAIC,OAAO,IAAK;EAC1CA,OAAO,CAACC,OAAO,CAACP,oBAAoB,CAAC;AACzC,CAAC;AACD,SAASQ,wBAAwBA,CAACN,EAAE,EAAE;EAClC,IAAI;MAAEO;IAAK,CAAC,GAAGP,EAAE;IAAEQ,OAAO,GAAGd,MAAM,CAACM,EAAE,EAAE,CAAC,MAAM,CAAC,CAAC;EACjD,MAAMS,UAAU,GAAGF,IAAI,IAAIG,QAAQ;EACnC;AACJ;AACA;EACI,IAAI,CAACb,SAAS,CAACc,GAAG,CAACF,UAAU,CAAC,EAAE;IAC5BZ,SAAS,CAACe,GAAG,CAACH,UAAU,EAAE,CAAC,CAAC,CAAC;EACjC;EACA,MAAMI,aAAa,GAAGhB,SAAS,CAACI,GAAG,CAACQ,UAAU,CAAC;EAC/C,MAAMK,GAAG,GAAGC,IAAI,CAACC,SAAS,CAACR,OAAO,CAAC;EACnC;AACJ;AACA;AACA;EACI,IAAI,CAACK,aAAa,CAACC,GAAG,CAAC,EAAE;IACrBD,aAAa,CAACC,GAAG,CAAC,GAAG,IAAIG,oBAAoB,CAACd,wBAAwB,EAAEe,MAAM,CAACC,MAAM,CAAC;MAAEZ;IAAK,CAAC,EAAEC,OAAO,CAAC,CAAC;EAC7G;EACA,OAAOK,aAAa,CAACC,GAAG,CAAC;AAC7B;AACA,SAASM,mBAAmBA,CAACC,OAAO,EAAEb,OAAO,EAAEc,QAAQ,EAAE;EACrD,MAAMC,yBAAyB,GAAGjB,wBAAwB,CAACE,OAAO,CAAC;EACnEb,iBAAiB,CAACiB,GAAG,CAACS,OAAO,EAAEC,QAAQ,CAAC;EACxCC,yBAAyB,CAACC,OAAO,CAACH,OAAO,CAAC;EAC1C,OAAO,MAAM;IACT1B,iBAAiB,CAAC8B,MAAM,CAACJ,OAAO,CAAC;IACjCE,yBAAyB,CAACG,SAAS,CAACL,OAAO,CAAC;EAChD,CAAC;AACL;AAEA,SAASD,mBAAmB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}