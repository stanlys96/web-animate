{"ast":null,"code":"import { __rest } from 'tslib';\nimport { visualElement } from '../index.mjs';\nimport { getOrigin, checkTargetForNewValues } from '../utils/setters.mjs';\nimport { buildHTMLStyles } from './utils/build-styles.mjs';\nimport { isCSSVariable } from '../dom/utils/is-css-variable.mjs';\nimport { parseDomVariant } from '../dom/utils/parse-dom-variant.mjs';\nimport { isTransformProp } from './utils/transform.mjs';\nimport { scrapeMotionValuesFromProps } from './utils/scrape-motion-values.mjs';\nimport { renderHTML } from './utils/render.mjs';\nimport { getDefaultValueType } from '../dom/value-types/defaults.mjs';\nimport { measureViewportBox } from '../../projection/utils/measure.mjs';\nfunction getComputedStyle(element) {\n  return window.getComputedStyle(element);\n}\nconst htmlConfig = {\n  treeType: \"dom\",\n  readValueFromInstance(domElement, key) {\n    if (isTransformProp(key)) {\n      const defaultType = getDefaultValueType(key);\n      return defaultType ? defaultType.default || 0 : 0;\n    } else {\n      const computedStyle = getComputedStyle(domElement);\n      const value = (isCSSVariable(key) ? computedStyle.getPropertyValue(key) : computedStyle[key]) || 0;\n      return typeof value === \"string\" ? value.trim() : value;\n    }\n  },\n  sortNodePosition(a, b) {\n    /**\n     * compareDocumentPosition returns a bitmask, by using the bitwise &\n     * we're returning true if 2 in that bitmask is set to true. 2 is set\n     * to true if b preceeds a.\n     */\n    return a.compareDocumentPosition(b) & 2 ? 1 : -1;\n  },\n  getBaseTarget(props, key) {\n    var _a;\n    return (_a = props.style) === null || _a === void 0 ? void 0 : _a[key];\n  },\n  measureViewportBox(element, _ref) {\n    let {\n      transformPagePoint\n    } = _ref;\n    return measureViewportBox(element, transformPagePoint);\n  },\n  /**\n   * Reset the transform on the current Element. This is called as part\n   * of a batched process across the entire layout tree. To remove this write\n   * cycle it'd be interesting to see if it's possible to \"undo\" all the current\n   * layout transforms up the tree in the same way this.getBoundingBoxWithoutTransforms\n   * works\n   */\n  resetTransform(element, domElement, props) {\n    const {\n      transformTemplate\n    } = props;\n    domElement.style.transform = transformTemplate ? transformTemplate({}, \"\") : \"none\";\n    // Ensure that whatever happens next, we restore our transform on the next frame\n    element.scheduleRender();\n  },\n  restoreTransform(instance, mutableState) {\n    instance.style.transform = mutableState.style.transform;\n  },\n  removeValueFromRenderState(key, _ref2) {\n    let {\n      vars,\n      style\n    } = _ref2;\n    delete vars[key];\n    delete style[key];\n  },\n  /**\n   * Ensure that HTML and Framer-specific value types like `px`->`%` and `Color`\n   * can be animated by Motion.\n   */\n  makeTargetAnimatable(element, _a, _b, isMounted) {\n    var {\n        transition,\n        transitionEnd\n      } = _a,\n      target = __rest(_a, [\"transition\", \"transitionEnd\"]);\n    var transformValues = _b.transformValues;\n    if (isMounted === void 0) {\n      isMounted = true;\n    }\n    let origin = getOrigin(target, transition || {}, element);\n    /**\n     * If Framer has provided a function to convert `Color` etc value types, convert them\n     */\n    if (transformValues) {\n      if (transitionEnd) transitionEnd = transformValues(transitionEnd);\n      if (target) target = transformValues(target);\n      if (origin) origin = transformValues(origin);\n    }\n    if (isMounted) {\n      checkTargetForNewValues(element, target, origin);\n      const parsed = parseDomVariant(element, target, origin, transitionEnd);\n      transitionEnd = parsed.transitionEnd;\n      target = parsed.target;\n    }\n    return Object.assign({\n      transition,\n      transitionEnd\n    }, target);\n  },\n  scrapeMotionValuesFromProps,\n  build(element, renderState, latestValues, options, props) {\n    if (element.isVisible !== undefined) {\n      renderState.style.visibility = element.isVisible ? \"visible\" : \"hidden\";\n    }\n    buildHTMLStyles(renderState, latestValues, options, props.transformTemplate);\n  },\n  render: renderHTML\n};\nconst htmlVisualElement = visualElement(htmlConfig);\nexport { getComputedStyle, htmlConfig, htmlVisualElement };","map":{"version":3,"names":["__rest","visualElement","getOrigin","checkTargetForNewValues","buildHTMLStyles","isCSSVariable","parseDomVariant","isTransformProp","scrapeMotionValuesFromProps","renderHTML","getDefaultValueType","measureViewportBox","getComputedStyle","element","window","htmlConfig","treeType","readValueFromInstance","domElement","key","defaultType","default","computedStyle","value","getPropertyValue","trim","sortNodePosition","a","b","compareDocumentPosition","getBaseTarget","props","_a","style","_ref","transformPagePoint","resetTransform","transformTemplate","transform","scheduleRender","restoreTransform","instance","mutableState","removeValueFromRenderState","_ref2","vars","makeTargetAnimatable","_b","isMounted","transition","transitionEnd","target","transformValues","origin","parsed","Object","assign","build","renderState","latestValues","options","isVisible","undefined","visibility","render","htmlVisualElement"],"sources":["/Users/stanly_s/Documents/yocia/node_modules/framer-motion/dist/es/render/html/visual-element.mjs"],"sourcesContent":["import { __rest } from 'tslib';\nimport { visualElement } from '../index.mjs';\nimport { getOrigin, checkTargetForNewValues } from '../utils/setters.mjs';\nimport { buildHTMLStyles } from './utils/build-styles.mjs';\nimport { isCSSVariable } from '../dom/utils/is-css-variable.mjs';\nimport { parseDomVariant } from '../dom/utils/parse-dom-variant.mjs';\nimport { isTransformProp } from './utils/transform.mjs';\nimport { scrapeMotionValuesFromProps } from './utils/scrape-motion-values.mjs';\nimport { renderHTML } from './utils/render.mjs';\nimport { getDefaultValueType } from '../dom/value-types/defaults.mjs';\nimport { measureViewportBox } from '../../projection/utils/measure.mjs';\n\nfunction getComputedStyle(element) {\n    return window.getComputedStyle(element);\n}\nconst htmlConfig = {\n    treeType: \"dom\",\n    readValueFromInstance(domElement, key) {\n        if (isTransformProp(key)) {\n            const defaultType = getDefaultValueType(key);\n            return defaultType ? defaultType.default || 0 : 0;\n        }\n        else {\n            const computedStyle = getComputedStyle(domElement);\n            const value = (isCSSVariable(key)\n                ? computedStyle.getPropertyValue(key)\n                : computedStyle[key]) || 0;\n            return typeof value === \"string\" ? value.trim() : value;\n        }\n    },\n    sortNodePosition(a, b) {\n        /**\n         * compareDocumentPosition returns a bitmask, by using the bitwise &\n         * we're returning true if 2 in that bitmask is set to true. 2 is set\n         * to true if b preceeds a.\n         */\n        return a.compareDocumentPosition(b) & 2 ? 1 : -1;\n    },\n    getBaseTarget(props, key) {\n        var _a;\n        return (_a = props.style) === null || _a === void 0 ? void 0 : _a[key];\n    },\n    measureViewportBox(element, { transformPagePoint }) {\n        return measureViewportBox(element, transformPagePoint);\n    },\n    /**\n     * Reset the transform on the current Element. This is called as part\n     * of a batched process across the entire layout tree. To remove this write\n     * cycle it'd be interesting to see if it's possible to \"undo\" all the current\n     * layout transforms up the tree in the same way this.getBoundingBoxWithoutTransforms\n     * works\n     */\n    resetTransform(element, domElement, props) {\n        const { transformTemplate } = props;\n        domElement.style.transform = transformTemplate\n            ? transformTemplate({}, \"\")\n            : \"none\";\n        // Ensure that whatever happens next, we restore our transform on the next frame\n        element.scheduleRender();\n    },\n    restoreTransform(instance, mutableState) {\n        instance.style.transform = mutableState.style.transform;\n    },\n    removeValueFromRenderState(key, { vars, style }) {\n        delete vars[key];\n        delete style[key];\n    },\n    /**\n     * Ensure that HTML and Framer-specific value types like `px`->`%` and `Color`\n     * can be animated by Motion.\n     */\n    makeTargetAnimatable(element, _a, _b, isMounted) {\n        var { transition, transitionEnd } = _a, target = __rest(_a, [\"transition\", \"transitionEnd\"]);\n        var transformValues = _b.transformValues;\n        if (isMounted === void 0) { isMounted = true; }\n        let origin = getOrigin(target, transition || {}, element);\n        /**\n         * If Framer has provided a function to convert `Color` etc value types, convert them\n         */\n        if (transformValues) {\n            if (transitionEnd)\n                transitionEnd = transformValues(transitionEnd);\n            if (target)\n                target = transformValues(target);\n            if (origin)\n                origin = transformValues(origin);\n        }\n        if (isMounted) {\n            checkTargetForNewValues(element, target, origin);\n            const parsed = parseDomVariant(element, target, origin, transitionEnd);\n            transitionEnd = parsed.transitionEnd;\n            target = parsed.target;\n        }\n        return Object.assign({ transition,\n            transitionEnd }, target);\n    },\n    scrapeMotionValuesFromProps,\n    build(element, renderState, latestValues, options, props) {\n        if (element.isVisible !== undefined) {\n            renderState.style.visibility = element.isVisible\n                ? \"visible\"\n                : \"hidden\";\n        }\n        buildHTMLStyles(renderState, latestValues, options, props.transformTemplate);\n    },\n    render: renderHTML,\n};\nconst htmlVisualElement = visualElement(htmlConfig);\n\nexport { getComputedStyle, htmlConfig, htmlVisualElement };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}