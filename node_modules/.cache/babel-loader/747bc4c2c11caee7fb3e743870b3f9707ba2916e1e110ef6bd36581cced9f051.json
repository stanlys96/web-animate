{"ast":null,"code":"import { __rest } from 'tslib';\nimport { inertia, animate } from 'popmotion';\nimport { secondsToMilliseconds } from '../../utils/time-conversion.mjs';\nimport { isEasingArray, easingDefinitionToFunction } from './easing.mjs';\nimport { isAnimatable } from './is-animatable.mjs';\nimport { getDefaultTransition } from './default-transitions.mjs';\nimport { warning } from 'hey-listen';\nimport { getAnimatableNone } from '../../render/dom/value-types/animatable-none.mjs';\nimport { instantAnimationState } from '../../utils/use-instant-transition-state.mjs';\nimport { resolveFinalValueInKeyframes } from '../../utils/resolve-value.mjs';\n\n/**\n * Decide whether a transition is defined on a given Transition.\n * This filters out orchestration options and returns true\n * if any options are left.\n */\nfunction isTransitionDefined(_a) {\n  var transition = __rest(_a, [\"when\", \"delay\", \"delayChildren\", \"staggerChildren\", \"staggerDirection\", \"repeat\", \"repeatType\", \"repeatDelay\", \"from\"]);\n  return !!Object.keys(transition).length;\n}\nlet legacyRepeatWarning = false;\n/**\n * Convert Framer Motion's Transition type into Popmotion-compatible options.\n */\nfunction convertTransitionToAnimationOptions(_a) {\n  var {\n      ease,\n      times,\n      yoyo,\n      flip,\n      loop\n    } = _a,\n    transition = __rest(_a, [\"ease\", \"times\", \"yoyo\", \"flip\", \"loop\"]);\n  const options = Object.assign({}, transition);\n  if (times) options[\"offset\"] = times;\n  /**\n   * Convert any existing durations from seconds to milliseconds\n   */\n  if (transition.duration) options[\"duration\"] = secondsToMilliseconds(transition.duration);\n  if (transition.repeatDelay) options.repeatDelay = secondsToMilliseconds(transition.repeatDelay);\n  /**\n   * Map easing names to Popmotion's easing functions\n   */\n  if (ease) {\n    options[\"ease\"] = isEasingArray(ease) ? ease.map(easingDefinitionToFunction) : easingDefinitionToFunction(ease);\n  }\n  /**\n   * Support legacy transition API\n   */\n  if (transition.type === \"tween\") options.type = \"keyframes\";\n  /**\n   * TODO: These options are officially removed from the API.\n   */\n  if (yoyo || loop || flip) {\n    warning(!legacyRepeatWarning, \"yoyo, loop and flip have been removed from the API. Replace with repeat and repeatType options.\");\n    legacyRepeatWarning = true;\n    if (yoyo) {\n      options.repeatType = \"reverse\";\n    } else if (loop) {\n      options.repeatType = \"loop\";\n    } else if (flip) {\n      options.repeatType = \"mirror\";\n    }\n    options.repeat = loop || yoyo || flip || transition.repeat;\n  }\n  /**\n   * TODO: Popmotion 9 has the ability to automatically detect whether to use\n   * a keyframes or spring animation, but does so by detecting velocity and other spring options.\n   * It'd be good to introduce a similar thing here.\n   */\n  if (transition.type !== \"spring\") options.type = \"keyframes\";\n  return options;\n}\n/**\n * Get the delay for a value by checking Transition with decreasing specificity.\n */\nfunction getDelayFromTransition(transition, key) {\n  var _a, _b;\n  const valueTransition = getValueTransition(transition, key) || {};\n  return (_b = (_a = valueTransition.delay) !== null && _a !== void 0 ? _a : transition.delay) !== null && _b !== void 0 ? _b : 0;\n}\nfunction hydrateKeyframes(options) {\n  if (Array.isArray(options.to) && options.to[0] === null) {\n    options.to = [...options.to];\n    options.to[0] = options.from;\n  }\n  return options;\n}\nfunction getPopmotionAnimationOptions(transition, options, key) {\n  var _a;\n  if (Array.isArray(options.to)) {\n    (_a = transition.duration) !== null && _a !== void 0 ? _a : transition.duration = 0.8;\n  }\n  hydrateKeyframes(options);\n  /**\n   * Get a default transition if none is determined to be defined.\n   */\n  if (!isTransitionDefined(transition)) {\n    transition = Object.assign(Object.assign({}, transition), getDefaultTransition(key, options.to));\n  }\n  return Object.assign(Object.assign({}, options), convertTransitionToAnimationOptions(transition));\n}\n/**\n *\n */\nfunction getAnimation(key, value, target, transition, onComplete) {\n  var _a;\n  const valueTransition = getValueTransition(transition, key);\n  let origin = (_a = valueTransition.from) !== null && _a !== void 0 ? _a : value.get();\n  const isTargetAnimatable = isAnimatable(key, target);\n  if (origin === \"none\" && isTargetAnimatable && typeof target === \"string\") {\n    /**\n     * If we're trying to animate from \"none\", try and get an animatable version\n     * of the target. This could be improved to work both ways.\n     */\n    origin = getAnimatableNone(key, target);\n  } else if (isZero(origin) && typeof target === \"string\") {\n    origin = getZeroUnit(target);\n  } else if (!Array.isArray(target) && isZero(target) && typeof origin === \"string\") {\n    target = getZeroUnit(origin);\n  }\n  const isOriginAnimatable = isAnimatable(key, origin);\n  warning(isOriginAnimatable === isTargetAnimatable, `You are trying to animate ${key} from \"${origin}\" to \"${target}\". ${origin} is not an animatable value - to enable this animation set ${origin} to a value animatable to ${target} via the \\`style\\` property.`);\n  function start() {\n    const options = {\n      from: origin,\n      to: target,\n      velocity: value.getVelocity(),\n      onComplete,\n      onUpdate: v => value.set(v)\n    };\n    return valueTransition.type === \"inertia\" || valueTransition.type === \"decay\" ? inertia(Object.assign(Object.assign({}, options), valueTransition)) : animate(Object.assign(Object.assign({}, getPopmotionAnimationOptions(valueTransition, options, key)), {\n      onUpdate: v => {\n        var _a;\n        options.onUpdate(v);\n        (_a = valueTransition.onUpdate) === null || _a === void 0 ? void 0 : _a.call(valueTransition, v);\n      },\n      onComplete: () => {\n        var _a;\n        options.onComplete();\n        (_a = valueTransition.onComplete) === null || _a === void 0 ? void 0 : _a.call(valueTransition);\n      }\n    }));\n  }\n  function set() {\n    var _a, _b;\n    const finalTarget = resolveFinalValueInKeyframes(target);\n    value.set(finalTarget);\n    onComplete();\n    (_a = valueTransition === null || valueTransition === void 0 ? void 0 : valueTransition.onUpdate) === null || _a === void 0 ? void 0 : _a.call(valueTransition, finalTarget);\n    (_b = valueTransition === null || valueTransition === void 0 ? void 0 : valueTransition.onComplete) === null || _b === void 0 ? void 0 : _b.call(valueTransition);\n    return {\n      stop: () => {}\n    };\n  }\n  return !isOriginAnimatable || !isTargetAnimatable || valueTransition.type === false ? set : start;\n}\nfunction isZero(value) {\n  return value === 0 || typeof value === \"string\" && parseFloat(value) === 0 && value.indexOf(\" \") === -1;\n}\nfunction getZeroUnit(potentialUnitType) {\n  return typeof potentialUnitType === \"number\" ? 0 : getAnimatableNone(\"\", potentialUnitType);\n}\nfunction getValueTransition(transition, key) {\n  return transition[key] || transition[\"default\"] || transition;\n}\n/**\n * Start animation on a MotionValue. This function is an interface between\n * Framer Motion and Popmotion\n */\nfunction startAnimation(key, value, target) {\n  let transition = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  if (instantAnimationState.current) {\n    transition = {\n      type: false\n    };\n  }\n  return value.start(onComplete => {\n    let delayTimer;\n    let controls;\n    const animation = getAnimation(key, value, target, transition, onComplete);\n    const delay = getDelayFromTransition(transition, key);\n    const start = () => controls = animation();\n    if (delay) {\n      delayTimer = window.setTimeout(start, secondsToMilliseconds(delay));\n    } else {\n      start();\n    }\n    return () => {\n      clearTimeout(delayTimer);\n      controls === null || controls === void 0 ? void 0 : controls.stop();\n    };\n  });\n}\nexport { convertTransitionToAnimationOptions, getDelayFromTransition, getPopmotionAnimationOptions, getValueTransition, getZeroUnit, hydrateKeyframes, isTransitionDefined, isZero, startAnimation };","map":{"version":3,"names":["__rest","inertia","animate","secondsToMilliseconds","isEasingArray","easingDefinitionToFunction","isAnimatable","getDefaultTransition","warning","getAnimatableNone","instantAnimationState","resolveFinalValueInKeyframes","isTransitionDefined","_a","transition","Object","keys","length","legacyRepeatWarning","convertTransitionToAnimationOptions","ease","times","yoyo","flip","loop","options","assign","duration","repeatDelay","map","type","repeatType","repeat","getDelayFromTransition","key","_b","valueTransition","getValueTransition","delay","hydrateKeyframes","Array","isArray","to","from","getPopmotionAnimationOptions","getAnimation","value","target","onComplete","origin","get","isTargetAnimatable","isZero","getZeroUnit","isOriginAnimatable","start","velocity","getVelocity","onUpdate","v","set","call","finalTarget","stop","parseFloat","indexOf","potentialUnitType","startAnimation","arguments","undefined","current","delayTimer","controls","animation","window","setTimeout","clearTimeout"],"sources":["/Users/stanly_s/Documents/yocia/node_modules/framer-motion/dist/es/animation/utils/transitions.mjs"],"sourcesContent":["import { __rest } from 'tslib';\nimport { inertia, animate } from 'popmotion';\nimport { secondsToMilliseconds } from '../../utils/time-conversion.mjs';\nimport { isEasingArray, easingDefinitionToFunction } from './easing.mjs';\nimport { isAnimatable } from './is-animatable.mjs';\nimport { getDefaultTransition } from './default-transitions.mjs';\nimport { warning } from 'hey-listen';\nimport { getAnimatableNone } from '../../render/dom/value-types/animatable-none.mjs';\nimport { instantAnimationState } from '../../utils/use-instant-transition-state.mjs';\nimport { resolveFinalValueInKeyframes } from '../../utils/resolve-value.mjs';\n\n/**\n * Decide whether a transition is defined on a given Transition.\n * This filters out orchestration options and returns true\n * if any options are left.\n */\nfunction isTransitionDefined(_a) {\n    var transition = __rest(_a, [\"when\", \"delay\", \"delayChildren\", \"staggerChildren\", \"staggerDirection\", \"repeat\", \"repeatType\", \"repeatDelay\", \"from\"]);\n    return !!Object.keys(transition).length;\n}\nlet legacyRepeatWarning = false;\n/**\n * Convert Framer Motion's Transition type into Popmotion-compatible options.\n */\nfunction convertTransitionToAnimationOptions(_a) {\n    var { ease, times, yoyo, flip, loop } = _a, transition = __rest(_a, [\"ease\", \"times\", \"yoyo\", \"flip\", \"loop\"]);\n    const options = Object.assign({}, transition);\n    if (times)\n        options[\"offset\"] = times;\n    /**\n     * Convert any existing durations from seconds to milliseconds\n     */\n    if (transition.duration)\n        options[\"duration\"] = secondsToMilliseconds(transition.duration);\n    if (transition.repeatDelay)\n        options.repeatDelay = secondsToMilliseconds(transition.repeatDelay);\n    /**\n     * Map easing names to Popmotion's easing functions\n     */\n    if (ease) {\n        options[\"ease\"] = isEasingArray(ease)\n            ? ease.map(easingDefinitionToFunction)\n            : easingDefinitionToFunction(ease);\n    }\n    /**\n     * Support legacy transition API\n     */\n    if (transition.type === \"tween\")\n        options.type = \"keyframes\";\n    /**\n     * TODO: These options are officially removed from the API.\n     */\n    if (yoyo || loop || flip) {\n        warning(!legacyRepeatWarning, \"yoyo, loop and flip have been removed from the API. Replace with repeat and repeatType options.\");\n        legacyRepeatWarning = true;\n        if (yoyo) {\n            options.repeatType = \"reverse\";\n        }\n        else if (loop) {\n            options.repeatType = \"loop\";\n        }\n        else if (flip) {\n            options.repeatType = \"mirror\";\n        }\n        options.repeat = loop || yoyo || flip || transition.repeat;\n    }\n    /**\n     * TODO: Popmotion 9 has the ability to automatically detect whether to use\n     * a keyframes or spring animation, but does so by detecting velocity and other spring options.\n     * It'd be good to introduce a similar thing here.\n     */\n    if (transition.type !== \"spring\")\n        options.type = \"keyframes\";\n    return options;\n}\n/**\n * Get the delay for a value by checking Transition with decreasing specificity.\n */\nfunction getDelayFromTransition(transition, key) {\n    var _a, _b;\n    const valueTransition = getValueTransition(transition, key) || {};\n    return (_b = (_a = valueTransition.delay) !== null && _a !== void 0 ? _a : transition.delay) !== null && _b !== void 0 ? _b : 0;\n}\nfunction hydrateKeyframes(options) {\n    if (Array.isArray(options.to) && options.to[0] === null) {\n        options.to = [...options.to];\n        options.to[0] = options.from;\n    }\n    return options;\n}\nfunction getPopmotionAnimationOptions(transition, options, key) {\n    var _a;\n    if (Array.isArray(options.to)) {\n        (_a = transition.duration) !== null && _a !== void 0 ? _a : (transition.duration = 0.8);\n    }\n    hydrateKeyframes(options);\n    /**\n     * Get a default transition if none is determined to be defined.\n     */\n    if (!isTransitionDefined(transition)) {\n        transition = Object.assign(Object.assign({}, transition), getDefaultTransition(key, options.to));\n    }\n    return Object.assign(Object.assign({}, options), convertTransitionToAnimationOptions(transition));\n}\n/**\n *\n */\nfunction getAnimation(key, value, target, transition, onComplete) {\n    var _a;\n    const valueTransition = getValueTransition(transition, key);\n    let origin = (_a = valueTransition.from) !== null && _a !== void 0 ? _a : value.get();\n    const isTargetAnimatable = isAnimatable(key, target);\n    if (origin === \"none\" && isTargetAnimatable && typeof target === \"string\") {\n        /**\n         * If we're trying to animate from \"none\", try and get an animatable version\n         * of the target. This could be improved to work both ways.\n         */\n        origin = getAnimatableNone(key, target);\n    }\n    else if (isZero(origin) && typeof target === \"string\") {\n        origin = getZeroUnit(target);\n    }\n    else if (!Array.isArray(target) &&\n        isZero(target) &&\n        typeof origin === \"string\") {\n        target = getZeroUnit(origin);\n    }\n    const isOriginAnimatable = isAnimatable(key, origin);\n    warning(isOriginAnimatable === isTargetAnimatable, `You are trying to animate ${key} from \"${origin}\" to \"${target}\". ${origin} is not an animatable value - to enable this animation set ${origin} to a value animatable to ${target} via the \\`style\\` property.`);\n    function start() {\n        const options = {\n            from: origin,\n            to: target,\n            velocity: value.getVelocity(),\n            onComplete,\n            onUpdate: (v) => value.set(v),\n        };\n        return valueTransition.type === \"inertia\" ||\n            valueTransition.type === \"decay\"\n            ? inertia(Object.assign(Object.assign({}, options), valueTransition))\n            : animate(Object.assign(Object.assign({}, getPopmotionAnimationOptions(valueTransition, options, key)), { onUpdate: (v) => {\n                    var _a;\n                    options.onUpdate(v);\n                    (_a = valueTransition.onUpdate) === null || _a === void 0 ? void 0 : _a.call(valueTransition, v);\n                }, onComplete: () => {\n                    var _a;\n                    options.onComplete();\n                    (_a = valueTransition.onComplete) === null || _a === void 0 ? void 0 : _a.call(valueTransition);\n                } }));\n    }\n    function set() {\n        var _a, _b;\n        const finalTarget = resolveFinalValueInKeyframes(target);\n        value.set(finalTarget);\n        onComplete();\n        (_a = valueTransition === null || valueTransition === void 0 ? void 0 : valueTransition.onUpdate) === null || _a === void 0 ? void 0 : _a.call(valueTransition, finalTarget);\n        (_b = valueTransition === null || valueTransition === void 0 ? void 0 : valueTransition.onComplete) === null || _b === void 0 ? void 0 : _b.call(valueTransition);\n        return { stop: () => { } };\n    }\n    return !isOriginAnimatable ||\n        !isTargetAnimatable ||\n        valueTransition.type === false\n        ? set\n        : start;\n}\nfunction isZero(value) {\n    return (value === 0 ||\n        (typeof value === \"string\" &&\n            parseFloat(value) === 0 &&\n            value.indexOf(\" \") === -1));\n}\nfunction getZeroUnit(potentialUnitType) {\n    return typeof potentialUnitType === \"number\"\n        ? 0\n        : getAnimatableNone(\"\", potentialUnitType);\n}\nfunction getValueTransition(transition, key) {\n    return transition[key] || transition[\"default\"] || transition;\n}\n/**\n * Start animation on a MotionValue. This function is an interface between\n * Framer Motion and Popmotion\n */\nfunction startAnimation(key, value, target, transition = {}) {\n    if (instantAnimationState.current) {\n        transition = { type: false };\n    }\n    return value.start((onComplete) => {\n        let delayTimer;\n        let controls;\n        const animation = getAnimation(key, value, target, transition, onComplete);\n        const delay = getDelayFromTransition(transition, key);\n        const start = () => (controls = animation());\n        if (delay) {\n            delayTimer = window.setTimeout(start, secondsToMilliseconds(delay));\n        }\n        else {\n            start();\n        }\n        return () => {\n            clearTimeout(delayTimer);\n            controls === null || controls === void 0 ? void 0 : controls.stop();\n        };\n    });\n}\n\nexport { convertTransitionToAnimationOptions, getDelayFromTransition, getPopmotionAnimationOptions, getValueTransition, getZeroUnit, hydrateKeyframes, isTransitionDefined, isZero, startAnimation };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}